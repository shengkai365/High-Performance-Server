## Thread

### 1. Theory

#### 1.1 一个线程占多大内存？

一个 Linux 的线程大概占 8M 内存。Linux 的栈是通过缺页来分配内存的，不是所有栈地址空间都分配了内存。因此，8M 是最大消耗，实际的内存消耗只会略大于实际需要的内存(内部损耗，每个在 4K 以内)。





#### 1.2 什么是并发和并行?

1. **并发:** 对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。
2. **并行:** 对于多个CPU，多个进程同时运行。
3. **区别:** 通俗来讲，它们虽然都说是"多个进程同时运行"，但是它们的"同时"不是一个概念。并行的"同时"是同一时刻可以多个任务在运行(处于running)，并发的"同时"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。



#### 1.3 说说进程、线程、协程是什么，区别是什么？

1. **进程**：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。

2. **线程**：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。

3. **协程**：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

4. **线程与进程的区别: **

  - 一个线程从属于一个进程；一个进程可以包含多个线程。
  - 一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。
  - 进程是系统资源调度的最小单位；线程CPU调度的最小单位。
  - 进程系统开销显著大于线程开销；线程需要的系统资源更少。
  - 进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
  - 进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。
  - 通信方式不一样。
  - 进程适应于多核、多机分布；线程适用于多核

5. **线程与协程的区别**：

  - 协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

  - 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

  - 一个线程可以有多个协程。



#### 1.4 协程是轻量级线程，轻量级表现在哪里？

1. **协程调用跟切换比线程效率高**：协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。
2. **协程占用内存少**：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。
3. **切换开销更少**：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。



#### 1.5 说说线程间通信的方式有哪些？

线程间的通信方式包括**临界区、互斥量、信号量、条件变量、读写锁**：
1. 临界区：每个线程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。
2. 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
3. 信号量：计数器，允许多个线程同时访问同一个资源。
4. 条件变量：通过条件变量通知操作的方式来保持多线程同步。
5. 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。



#### 1.6 说说线程同步方式有哪些？

线程间的同步方式包括**互斥锁、信号量、条件变量、读写锁**：
1. 互斥锁：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
2. 信号量：计数器，允许多个线程同时访问同一个资源。
3. 条件变量：通过条件变量通知操作的方式来保持多线程同步。
4. 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。



#### 1.7 说说什么是死锁，产生的条件，如何解决？

1. 死锁: 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两
    只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。
2. 产生的条件：死锁发生有四个必要条件：
  - 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
  - 请求保持条件：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；
  - 不可剥夺条件：进程已获得的资源，只能自己释放，不可剥夺；
  - 环路等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
3. 如何解决：
（1）资源一次性分配，从而解决请求保持的问题
（2）可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；
（3）资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反。



#### 1.8 有了进程，为什么还要有线程？

1. **原因**
    进程在早期的多任务操作系统中是基本的**执行单元**。每次进程切换，都要先保存进程资源然后再恢复，这称为上下文切换。**但是进程频繁切换将引起额外开销，从而严重影响系统的性能**。为了减少进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小**粒度**的执行单元来实现并发执行，这就是**线程**。
2. **线程与进程对比**
  - **进程间的信息难以共享**。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一
    些进程间通信方式，在进程间进行信息交换。但**多个线程共享**进程的内存，如代码段、数据段、扩展段，线程间进行信息交换十分方便。
  - 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 `fork()` 调用在时间上的开销依然不菲。但**创建线程比创建进程通常要快 10 倍甚至更多**。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。

#### 1.9 单核机器上写多线程程序，是否要考虑加锁，为什么？

在单核机器上写多线程程序，仍然需要线程锁。

原因：因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，**不使用线程锁的前提下，可能会导致共享数据修改引起冲突。**



#### 1.10 说说多线程和多进程的不同？

1. 一个线程从属于一个进程；一个进程可以包含多个线程。
2. 一个线程挂掉，对应的进程挂掉，多线程也挂掉；一个进程挂掉，不会影响其他进程，多进程稳定。
3. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
4. 多个进程在执行时拥有各自独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。
5. 多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
6. 通信方式不一样。
7. 多进程适应于多核、多机分布；多线程适用于多核



#### 1.11 进程和线程相比，为什么慢？

1. 进程系统开销显著大于线程开销；线程需要的系统资源更少。
2. 进程切换开销比线程大。多进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
3. 进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。





#### 1.12 简述互斥锁的机制，互斥锁与读写的区别？

1. **互斥锁机制**：`mutex`，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。
2. **互斥锁和读写锁**：
  - 读写锁区分读者和写者，而互斥锁不区分
  - 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。



#### 1.13 说说什么是信号量，有什么作用？

1. **概念**：信号量本质上是一个计数器，用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。
2. **原理**：由于信号量只能进行两种操作等待和发送信号，即`P(sv)`和`V(sv)`，具体的行为如下：
  - `P(sv)`操作：如果`sv`的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行（信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位）。
  - `V(sv)`操作：如果有其他进程因等待`sv`而被挂起，就让它恢复运行，如果没有进程因等待`sv`而挂起，就给它加1（若此时信号量的值为0，则进程进入挂起状态，直到信号量的值大于0，若进程被唤醒则返回至第一步）。
3. **作用**：用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。



#### 1.14 进程、线程的中断切换的过程是怎样的？

上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。
1. **进程上下文切换**
（1）保护被中断进程的处理器现场信息
（2）修改被中断进程的进程控制块有关信息，如进程状态等
（3）把被中断进程的进程控制块加入有关队列
（4）选择下一个占有处理器运行的进程
（5）根据被选中进程设置操作系统用到的地址转换和存储保护信息**切换页目录以使用新的地址空间切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）**
（6）根据被选中进程恢复处理器现场
2. 线程上下文切换
（1）保护被中断线程的处理器现场信息
（2）修改被中断线程的线程控制块有关信息，如线程状态等
（3）把被中断线程的线程控制块加入有关队列
（4）选择下一个占有处理器运行的线程
（5）根据被选中线程设置操作系统用到的存储保护信息**切换内核栈和硬件上下文（切换堆栈，以及各寄存器）**
（6）根据被选中线程恢复处理器现场



#### 1.15 简述自旋锁和互斥锁的使用场景

1. **互斥锁**用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑
（1）临界区有 IO 操作
（2）临界区代码复杂或者循环量大
（3）临界区竞争非常激烈
（4）单核处理器
2. **自旋锁**就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下。



#### 1.16 为什么要创建线程池? 线程池的设计思路？

1. **为什么要创建线程池:**
创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。同时线程池也是为了提升系统效率。

1. **设计思路**：
实现线程池有以下几个步骤：
（1）设置一个生产者消费者队列，作为临界资源。
（2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行
（3）当任务队列为空时，所有线程阻塞。
（4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。

3. **线程池中线程数量**：
    线程数量和哪些因素有关：CPU，IO、并行、并发:

  ```
  如果是CPU密集型应用，则线程池大小设置为：CPU数目+1
  如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1
  最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目
  ```

  所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。


2. **线程池的核心线程与普通线程：**
任务队列可以存放100个任务，此时为空，线程池里有10个核心线程，若突然来了10个任务，那么刚好10个核心线程直接处理；若又来了90个任务，此时核心线程来不及处理，那么有80个任务先入队列，再创建核心线程处理任务；若又来了120个任务，此时任务队列已满，不得已，就得创建20个普通线程来处理多余的任务。以上是线程池的工作流程。



 

### 2. Practice

`pthread.h`函数说明参考地址：https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread.h.html

#### 2.1 线程操作

| 功能                         | 函数             |
| ---------------------------- | ---------------- |
| **创建一个新线程**           | `pthread_create` |
| **获得调用线程的**ID         | `pthread_self`   |
| **比较线程**ID               | `pthread_equal`  |
| **终止当前线程**             | `pthread_exit`   |
| **等待线程结束并回收其资源** | `pthread_join`   |
| **分离一个线程**             | `pthread_detach` |
| **向一个线程发送取消请求**   | `pthread_cancel` |


- 创建一个新线程

  `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);`

  ```
  - 功能：创建一个具有指定参数的子线程
  - 头文件: #include <pthread.h>
  - 参数：
      - thread：传出参数，创建线程的 id 指针
      - attr : 设置线程的属性，一般使用默认值，NULL
      - start_routine : 参数和返回值是 void 类型的指针函数
      - arg : start_routine的实参
  - 返回值：
      成功：0
      失败：返回错误号,和errno不太一样。
      获取错误号信息：  char * strerror(int errnum);
  ```

- 终止一个线程

  `void pthread_exit(void *retval);`

  ```
  - 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程
  - 头文件: #include <pthread.h>
  - 参数:
  	- retval:需要传递一个指针，作为一个返回值，可以在 pthread_join()中获取
  - 返回值: void
  ```

- 获得调用线程的ID

  `pthread_t pthread_self(void);`

  ```
  - 功能: 获得调用线程的ID
  - 头文件: #include <pthread.h>
  - 参数: void
  - 返回值: pthread_t(线程id指针)
  ```

- 比较线程ID

  `int pthread_equal(pthread_t t1, pthread_t t2);`

  ```
  - 功能：比较两个线程ID是否相等
  - 头文件: #include <pthread.h>
  - 参数: 
  	- t1: 线程id
  	- t2: 线程id
  - 返回值: t1和t2相等返回非零,否则返回0
  ```

- 等待线程结束

  `int pthread_join(pthread_t thread, void **retval);`

  ```
  - 功能：这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被
  	   等待的线程结束为止，当函数返回时，被等待线程的资源被收回.
  - 头文件: #include <pthread.h>
  - 参数:
  	- thread: 被等待的子线程ID
  	- retval: 一个用户定义的指针，它可以用来存储被等待子线程的返回值
  - 返回值:
  	成功返回0,否则返回错误的编号
  ```

- 分离一个线程

  `int pthread_detach(pthread_t thread);`

  ```
  - 功能: 线程资源释放方式设置函数. 
  	- 分离一个线程, 被分离的线程在终止的时候，会自动释放资源返回给系统。
  	- 不能多次分离，会产生不可预料的行为。
  	- 不能去连接一个已经分离的线程，会报错。
  	
  - 头文件: #include <pthread.h>
  - 参数：需要分离的线程的ID
  - 返回值：
      成功：0
      失败：返回错误号
  ```

- **线程取消函数**

  `int pthread_cancel(pthread_t thread);`

  ```
  - 头文件：#include <pthread.h>
  - 功能：取消线程（让线程终止）
  	- 取消某个线程，可以终止某个线程的运行，并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。
      - 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。
  - 参数：
  	- thread: 要取消线程ID
  - 返回值：
  	- 成功返回0
  	- 失败返回错误的编号
  ```



#### 2.2 线程属性

| 功能                                 | 函数                          |
| ------------------------------------ | ----------------------------- |
| **初始化线程属性对象**               | `pthread_attr_init`           |
| **销毁线程属性对象**                 | `pthread_attr_destroy`        |
| **在线程属性对象中设置分离状态属性** | `pthread_attr_getdetachstate` |
| **获取线程属性对象中的分离状态属性** | `pthread_attr_setdetachstate` |

- 初始化线程属性对象

  `int pthread_attr_init(pthread_attr_t *attr);`

  ```
  头文件：#include <pthread.h>
  说明：pthread_attr_init 实现时为属性对象分配了动态内存空间
       Posix 线程中的线程属性 pthread_attr_t主要包括scope属性、detach属性、堆栈地址、堆栈大小、优先级
  形参：
      attr: 指向一个线程属性的指针
  
  返回值：若是成功返回0,否则返回错误的编号
  ```

  

- 销毁线程属性对象

  `int pthread_attr_destroy(pthread_attr_t *attr);`

  ```
  头文件：#include <pthread.h>
  说明：经 pthread_attr_destroy 去除初始化之后的 pthread_attr_t 结构被 pthread_create 函数调用，将会导致其返回错误
  
  形参：
      attr: 指向一个线程属性的指针
  
  返回值：若是成功返回0,否则返回错误的编号
  ```

  

- 在线程属性对象中设置分离状态属性

  `int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);`

  ```
  头文件：#include <pthread.h>
  说明：修改线程分离状态属性；pthread_detach()分离释放线程资源函数
  
  形参：
      attr: 指向一个线程属性的指针
      detachstate: 有两个取值
  		- PTHREAD_CREATE_JOINABLE（可连接），使用attr创建的所有线程处于可连接状态，线程终止不会回收相关资源，需在其他线程调用pthread_detach()或pthread_join()函数
  		- PTHREAD_CREATE_DETACHED(分离)，使用attr创建的所有线程处于分离状态，这类线程终止带有此状态的线程相关资源将被系统收回
  
  返回值：若是成功返回0,否则返回错误的编号
  ```

  

- 获取线程属性对象中的分离状态属性

  `int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);`

  ```
  头文件：#include <pthread.h>
  说明：获取线程分离状态属性；pthread_detach()分离释放线程资源函数
  
  形参：
      attr          指向一个线程属性的指针
      detachstate   保存返回的分离状态属性
  
  返回值：若是成功返回0,否则返回错误的编号
  ```

  

#### 2.3 互斥量

| 功能           | 函数                    |
| -------------- | ----------------------- |
| **初始化**     | `pthread_mutex_init`    |
| **销毁**       | `pthread_mutex_destroy` |
| **阻塞加锁**   | `pthread_mutex_lock`    |
| **非阻塞加锁** | `pthread_mutex_trylock` |
| **解锁**       | `pthread_mutex_unlock`  |

- 初始化互斥锁

  `int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);`

  ```
  头文件：#include <pthread.h>
  参数：
  	mutex: 需要初始化的互斥量
  	attr: 互斥量的相关属性，NULL
  修饰符：
  	restrict: 修饰的指针，不能由另外的一个指针进行操作
  		pthread_mutex_t *restrict mutex = xxx;
          pthread_mutex_t * mutex1 = mutex;
  ```

  

- 销毁互斥锁

  `int pthread_mutex_destroy(pthread_mutex_t *mutex);`

- 阻塞方式加锁

  `int pthread_mutex_lock(pthread_mutex_t *mutex);`

- 非阻塞方式加锁

  `int pthread_mutex_trylock(pthread_mutex_t *mutex);`

- 解锁

  `int pthread_mutex_unlock(pthread_mutex_t *mutex);`

  

#### 2.4 读写锁

`pthread_rwlock_t`  0 至 n 个读线程或 0 至 1 个写线程获得锁

| 功能               | 函数                       |
| ------------------ | -------------------------- |
| **初始化**         | `pthread_rwlock_init`      |
| **销毁**           | `pthread_rwlock_destroy`   |
| **加读锁、阻塞**   | `pthread_rwlock_rdlock`    |
| **加读锁、非阻塞** | `pthread_rwlock_tryrdlock` |
| **加写锁、阻塞**   | `pthread_rwlock_wrlock`    |
| **加写锁、非阻塞** | `pthread_rwlock_trywrlock` |
| **解锁**           | `pthread_rwlock_unlock`    |

- `int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);`
- `int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);`
- `int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);`
- `int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);`
- `int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);`
- `int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);`
- `int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);`



#### 2.5 条件变量

与互斥锁不同，**条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止**。**通常条件变量和互斥锁同时使用。**

| 功能             | 函数                     |
| ---------------- | ------------------------ |
| **初始化**       | `pthread_cond_init`      |
| **销毁**         | `pthread_cond_destroy`   |
| **阻塞等待条件** | `pthread_cond_wait`      |
| **超时等待条件** | `pthread_cond_timedwait` |
| **通知条件**     | `pthread_cond_signal`    |
| **广播通知条件** | `pthread_cond_broadcast` |

- 初始化

  ```
  #include <pthread.h>
  
  int pthread_cond_init(pthread_cond_t *restrict cond, pthread_condattr_t *restrict attr);
  int pthread_cond_destroy(pthread_cond_t *cond);
  
  成功则返回0, 出错则返回错误编号.
  
  当 pthread_cond_init 的 attr 参数为 NULL 时, 会创建一个默认属性的条件变量; 
  ```

  

- 等待条件

  ```
  #include <pthread.h>
  
  int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restric mutex);
  int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict timeout);
  
  成功则返回0, 出错则返回错误编号.
  
  这两个函数分别是阻塞等待和超时等待.
  
  等待条件函数等待条件变为真, 传递给pthread_cond_wait的互斥量对条件进行保护, 调用者把锁住的互斥量传递给函数. 函数把调用线程放到等待条件的线程列表上, 然后对互斥量解锁, 这两个操作是原子的. 这样便关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道, 这样线程就不会错过条件的任何变化.
  
  当 pthread_cond_wait 返回时, 互斥量再次被锁住.
  ```

  

- 通知条件

  ```
  #include <pthread.h>
  
  int pthread_cond_signal(pthread_cond_t *cond);
  int pthread_cond_broadcast(pthread_cond_t *cond);
  
  成功则返回0, 出错则返回错误编号.
  
  这两个函数用于通知线程条件已经满足. 调用这两个函数, 也称向线程或条件发送信号. 必须注意, 一定要在改变条件状态以后再给线程发送信号.
  ```

  

#### 2.6 信号量

| 功能                                | 函数            |
| ----------------------------------- | --------------- |
| **初始化**                          | `sem_init`      |
| **销毁**                            | `sem_destroy`   |
| **递减/锁定信号量，0时阻塞**        | `sem_wait`      |
| **递减信号量，0时返回错误号**       | `sem_trywait`   |
| **递减/锁定信号量，超时返回错误号** | `sem_timedwait` |
| **递增信号量**                      | `sem_post`      |
| **获取信号量值**                    | `sem_getvalue`  |

- `int sem_init(sem_t *sem, int pshared, unsigned int value);`

  ```
  #include <semaphore.h>
  int sem_init(sem_t *sem, int pshared, unsigned int value);
      - 初始化信号量
      - 参数：
          - sem : 信号量变量的地址
          - pshared : 0 用在线程间 ，非 0 用在进程间
          - value : 信号量中的值
  ```

- `int sem_destroy(sem_t *sem);`

- `int sem_wait(sem_t *sem);`

- `int sem_trywait(sem_t *sem);`

- `int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);`

- `int sem_post(sem_t *sem);`

- `int sem_getvalue(sem_t *sem, int *sval);`